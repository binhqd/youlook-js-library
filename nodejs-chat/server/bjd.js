/**
 * bjd.js
 * BellaJS Deliverer for server
 * Author by @ndaidong at Twitter
 * Copyright by *.bjlab.us, *.youlook.net
*/
;(function(){
	
	// some helpers from BellaJS
	function unique(a){
		var r = [];
		for(var i = 0; i < a.length; i++){
		   if(r.indexOf(a[i]) === -1){
				r.push(a[i]);
		   }
		}
		return r;			
	}
	function max(a){
		return Math.max.apply({}, a);
	}
	function min(a){
		return Math.min.apply({}, a);
	}    
	function contains(a, el, key){
		for(var i=0;i<a.length;i++){
			var val = a[i];
			if((key && val[key]===el[key])||(val===el)){
				return true;
			}
		};
		return false;			
	}
	function msort(a, p, d){
		var dn = (!d||d==='asc')?1:-1;
		a.sort(function(m, n){
			return (m[p]>n[p])?dn:(m[p]<n[p]?(-1*dn):0);
		});
		return a;			
	}
	function empty(a){
		for(var i=a.length-1;i>=0;i--){
			 delete a[i];
		}
		a.length=0;	
	}
	
	function now(){
		return (new Date()).getTime();
	}
	
	function generateId(leng, prefix){
		function gid(l){
		  var s = '', chr = '';
		  var lng = l || 16;
			while(s.length<lng){
				chr = Math.floor(Math.random()*2147483648 ^ (new Date())).toString(36).substring(1);
				if(chr!='_'){s+=chr}
			}
			return s;
		}			
		return (prefix?(prefix):'')+gid((leng?leng:16)-(prefix?prefix.length:0));
	}
	
	
	// Some temp object travered from global scope
	var _io, _socket;
	
	// Some vars for tracking
	var lastAddedJunction = null, lastSentPacket = null, lastSocketSend = null;
	
	// Main storage for client connections and socket
	
	var Store = {
		relations : {},
		lines : [], 
		// lines is an array that contains all online user
		
		junctions : [],
		/*
			junctions property contains all user screen that connecting to bjDeliverer throught.
			Every junction is an object with the below data structure
			{
				user : String userid,
				clientId : String client id that generated by client
				socketId : String socket id that generated by server, every junction has just one socketId value,
				junctionId : String junction id that generated by client (to make sure that we can keep the connection after socket die and reconnect with new socket)
			}
		*/

		
		/**
		 * Methods to handle lines
		 * 		addUser();
		 * 		removeUser();
		 * 		isOnline();
		 * 		areOnlines();
		 * 		getOnlineUsers();
		 * 		
		***/
		
		addUser : function(user){
			if(!contains(this.lines, user)){
				this.lines.push(user);
				EventHandler.onAddToLines(user);
				return true;
			}
			return false;
		},
		removeUser : function(user){
			var r = false;
			var ls = this.lines;
			for(var i=ls.length-1; i>=0; i--){
				if(ls[i]===user){
					this.lines.splice(i, 1);
					EventHandler.onRemoveFromLines(user);
					r = true;
					break;
				}
			}
			return r;
		},
		isOnline : function(user){
			return contains(this.lines, user);
		},
		areOnlines : function(collection){
			var ls = this.lines;
			return collection.filter(function(uid){
				return contains(ls, uid);
			});
		},
		getOnlineUsers : function(){
			return this.lines;
		},
				
		/**
		 * Methods to handle junctions
		 * 		addJunction();
		 * 		removeJunction();
		 * 		cleanJunction();
		 * 		getJunction();
		 * 		getAllJunctions();
		 * 		getCountJunctions();
		 * 		getAllUserJunctions();
		 * 		getAllClientJunctions();
		 * 		cleanJunction();
		 * 		cleanUserJunction();
		***/
		addJunction : function(ob){
			
			var user = ob.user;
			var clientId = ob.clientId;
			var socketId = ob.socketId;
			var junctionId = ob.junctionId;
			
			if(!!user && !!clientId && !!socketId && !!junctionId){
				var lis = this.junctions;
				var r = false;
				if(lis.length>0){
					for(var i=0;i<lis.length;i++){
						var c = lis[i];
						if(c.clientId===clientId && c.socketId==socketId && c.user===user && c.junctionId===junctionId){
							r = true;
							break;
						}
					}
				}
				if(!r){
					var junc = {
						user : user,
						clientId : clientId,
						socketId : socketId,
						junctionId : junctionId
					}
					if(!lastAddedJunction || lastAddedJunction!=junc){
						lastAddedJunction = junc;
						this.junctions.push(junc);
						EventHandler.onJunctionAdded(junc);
					}
				}
			}
		},
		
		removeJunction : function(ob, callback, silent){
			
			var r = false;
			var s = silent || false;
			
			var user = ob.user || false;
			var clientId = ob.clientId || false;
			var socketId = ob.socketId || false;
			var junctionId = ob.junctionId || false;
			
			if(!!user || !!clientId || !!socketId || junctionId){
				var lis = this.junctions;
				if(lis.length>0){
					for(var i=lis.length-1;i>=0;i--){
						var c = lis[i];
						if((!!user && c.user==user) || (!!clientId && c.clientId==clientId) || (!!socketId && c.socketId==socketId) || (!!junctionId && c.junctionId==junctionId)){
							r = true;
							this.junctions.splice(i, 1);
							if(!!callback){
								callback();
							}
							break;
						}
					}
				}		
			}
			return r;
		},
		
		cleanJunction : function(ob, callback){
			return this.removeJunction(ob, callback, true);
		},
		
		cleanUserJunction : function(clientId, user){
			var us = [];
			var allJunctions = this.getAllJunctions();
			var clientJunctions = this.getAllClientJunctions(clientId);
			clientJunctions.forEach(function(item){
				if(item.user!=user){
					us.push(item.user);
					for(var i=allJunctions.length-1;i>=0;i--){
						var jitem = allJunctions[i];
						if(jitem.user==item.user && jitem.junctionId==item.junctionId){
							allJunctions.splice(i, 1);
						}
					}
					this.junctions = allJunctions;
				}
			});
			if(us.length>0){
				us = unique(us);
				console.log('User to clean');
				console.log(us);				
				for(var i=us.length-1;i>=0;i--){
					var ujs = Store.getAllUserJunctions(us[i]);
					if(ujs.length==0){
						Store.removeUser(us[i]);
					}
				}
			}
		},
		
		getJunction : function(ob){
			var r = false;
			
			var user = ob.user || false;
			var clientId = ob.clientId || false;
			var socketId = ob.socketId || false;
			
			if(!!user || !!clientId || !!socketId){
				var lis = this.junctions;
				if(lis.length>0){
					for(var i=lis.length-1;i>=0;i--){
						var c = lis[i];
						if((!!user && c.user==user) || (!!clientId && c.clientId==clientId) || (!!socketId && c.socketId==socketId)){
							r = c;
							break;
						}
					}
				}
			}
			
			return r;	
		},
		getAllJunctions : function(){
			return this.junctions;
		},
		getCountJunctions : function(){
			return this.junctions.length;
		},
		getAllUserJunctions : function(user){
			return this.junctions.filter(function(item){
				return item.user===user;
			});
		},
		getAllClientJunctions : function(clientId){
			return this.junctions.filter(function(item){
				return item.clientId===clientId;
			});
		},
		getAllClientJunctionsBySocket : function(socketId){
			return this.junctions.filter(function(item){
				return item.socketId===socketId;
			});
		},
		
		/**
		 * Methods to handle socket collection
		 * 		getAllUserSockets();
		 * 		
		***/
		getAllUserSockets : function(user){
			var r = [];
			var ujs = this.getAllUserJunctions(user);
			if(ujs.length>0){
				ujs.forEach(function(item){
					r.push(item.socketId);
				});
			}
			return r;
		},
		
		// other helpers
		setUserConnectors : function(user, connectors){
			this.relations[user] = connectors;
		},
		getUserConnectors : function(user){
			return this.relations[user] || [];
		},
		getUserOnlineConnectors : function(user){
			var re = [];
			var cns = this.getUserConnectors(user);
			if(cns.length>0){
				cns.forEach(function(uid){
					if(Store.isOnline(uid)){
						re.push(uid);
					}
				});
			}
			return re;
		}
	}
	
	var EventHandler = {
		onAddToLines : function(user){
			console.log('Join');
			console.log(user);
		},
		onRemoveFromLines : function(user){
			console.log('Leave');
			console.log(user);
			console.log('Online user');
			console.log(Store.getOnlineUsers());
			
			var onlines = Store.getUserOnlineConnectors(user);
			console.log('Online connectors');
			console.log(onlines);
			
			if(!!onlines){
				// notify to all online connector of this user
				var data = {
					type : 'connectorStatus',
					status : 0,
					connector : user
				}
				mnotify(onlines, data);
			}			
		},
		onDisconnect : function(junc){
			console.log('Disconnected junction');
			console.log(junc);		
			var clientId = junc.clientId;
			var user = junc.user;
			Store.cleanJunction({clientId : clientId});
			this.onJunctionRemoved(junc);
		},
		onJunctionAdded : function(junc){
			console.log('New junction');
			console.log(junc);
			var user = junc.user;
			if(!!user){
				var test = Store.isOnline(user);
				if(!test){
					Store.addUser(user);
				}
			}
			var ls = Store.getAllClientJunctions(junc.clientId);
			if(!!ls && ls.length>0){
				var data = {
					type : 'clientStatus',
					status : 1,
					socketId : junc.socketId,
					junctionId : junc.junctionId,
					connector : user
				}
				ls.forEach(function(item){
					var socketId = item.socketId;
					if(socketId!=junc.socketId){
						sendToJunction(socketId, data);
					}
				});
				
			}
		},
		onJunctionRemoved : function(junc){
			console.log('Lost junction');
			console.log(junc);
			var user = junc.user;
			var ls = Store.getAllClientJunctions(junc.clientId);
			if(!!ls && ls.length>0){
				var data = {
					type : 'clientStatus',
					status : 0,
					socketId : junc.socketId,
					junctionId : junc.junctionId,
					connector : user
				}
				ls.forEach(function(item){
					var socketId = item.socketId;
					Store.cleanJunction({socketId : socketId}, function(){
						if(junc.socketId!=socketId){
							sendToJunction(socketId, data);
						}
					});
				});
				
				// now, all junctions in same client have been removed
			}
			// we try to check if there is any junction on other devices
			// if not found anything, we will set user as offline and notify his online connectors
			var remain = Store.getAllUserJunctions(user);
			if(!remain || remain.length===0){
				Store.removeUser(user);
			}
		}
	}
	
	function mnotify(us, data){
		us.forEach(function(uid){
			notify(uid, data);
		});
	}
	function notify(uid, data){
		var sockets = Store.getAllUserSockets(uid);
		if(sockets.length>0){
			sockets.forEach(function(sid){
				sendToJunction(sid, data);
			});
		}
	}
	function sendToJunction(socketId, data){
		if(!!_io){
			if((!lastSentPacket && !lastSocketSend) || (lastSentPacket!=data || socketId!=lastSocketSend)){
				lastSentPacket = data;
				lastSocketSend = socketId;
				_io.sockets.socket(socketId).emit('serverSignal', data);	
			}
		}
	}
		
	function connect(message, socket, io){
		console.log('Connected');
		var socketId = socket.id;
		var clientId = message.clientId;
		var junctionId = message.junctionId;
		var user = message.user;
		
		io.sockets.socket(socketId).emit('initialized', {
			socketId : socketId
		});			
		
		Store.addJunction({
			user : user, 
			clientId : clientId,
			socketId : socketId,
			junctionId : junctionId
		});
	}
	
	function connectSocket(io, socket){
		console.log('Socket connected');
		var socketId = socket.id;
		io.sockets.socket(socketId).emit('initialized', {
			socketId : socketId
		});		
	}
	
	function disconnect(message, socket, io){
		console.log('Disconnected');
		Store.removeJunction({socketId : socket.id});
	}
	function disconnectSocket(sid){
		console.log('Socket Disconnected');
		var junctions = Store.getAllClientJunctionsBySocket(sid);
		if(!!junctions && junctions.length>0){
			EventHandler.onDisconnect(junctions[0]);
		}
	}
		
	function signout(message, socket, io){
		console.log('Signout');
		console.log(message);
		var user = message.user;
		Store.removeJunction({socketId : socket.id});
	}
	
	function signin(message, socket, io){
		console.log('Signin');
		console.log(message);
		var socketId = socket.id;
		var clientId = message.clientId;
		var junctionId = message.junctionId;
		var user = message.user;
		
		Store.setUserConnectors(user, message.connectors);
		
		Store.addJunction({
			user : user, 
			clientId : clientId,
			socketId : socketId,
			junctionId : junctionId
		});		
		
		// update other junctions on same device
		var jcs = Store.getAllClientJunctions(clientId);
		if(!!jcs && jcs.length>0){
			console.log('Client junctions');
			console.log(jcs);
			var data = {
				type : 'clientStatus',
				status : 1,
				socketId : socketId,
				junctionId : junctionId,
				connector : user
			}
			jcs.forEach(function(c){
				if(c.junctionId!=junctionId){
					sendToJunction(c.socketId, data);
				}
			});
		}
		Store.cleanUserJunction(clientId, user);
		
		console.log('Relations');
		console.log(Store.getUserConnectors(user));
		console.log('Online user');
		console.log(Store.getOnlineUsers());
		
		
		var onlines = Store.getUserOnlineConnectors(user);
		console.log('Online connectors');
		console.log(onlines);
		
		if(!!onlines){
			// notify to all online connector of this user
			var data = {
				type : 'connectorStatus',
				status : 1,
				connector : user
			}
			mnotify(onlines, data);
			
			// send to user list of online connectors
			notify(user, {
				type : 'connectorStatus',
				status : 1,
				connectors : onlines
			});
		}
	}
	
	function delivery(message, socket, io){
		console.log('Delivery message');
		console.log(message.msgPacket);
		
		var socketId = socket.id;
		var clientId = message.clientId;
		var junctionId = message.junctionId;
		var user = message.user;
		
		var msg = message.msgPacket;
		msg.time = now(); // add time property
		
		// if sender open many junctions, they need to be synced as well
		if(msg.from===user){
			var data = {
				type : 'message',
				message : msg
			}			
			var senderJuncs = Store.getAllUserJunctions(msg.from);
			if(!!senderJuncs && senderJuncs.length>1){
				senderJuncs.forEach(function(c){
					if(c.junctionId!=junctionId){
						sendToJunction(c.socketId, data);
					}
				});		
			}
			var receiverJuncs = Store.getAllUserJunctions(msg.to);
			if(!!receiverJuncs){
				receiverJuncs.forEach(function(c){
					sendToJunction(c.socketId, data);
				});		
			}
		}
	}
	
	var bjd = {
		connect : function(io, socket){
			_io = io;
			_socket = socket;
			connectSocket(io, socket);
		},
		disconnect : function(socket){
			_socket = socket;
			disconnectSocket(socket.id);
		},
		onClientSignal : function(io, socket, message){

			_io = io;
			_socket = socket;
					
			switch (message.type){
				case 'connect' 		: connect(message, socket, io);break;
				case 'disconnect' 	: disconnect(message, socket, io);break;
				case 'signin' 		: signin(message, socket, io); break;
				case 'signout' 		: signout(message, socket, io); break;
				case 'message' 		: delivery(message, socket, io); break;
			}
		}
	}
	
	module.exports = bjd;
})();
